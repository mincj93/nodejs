------------------------------------------------------------------------------------
Node
    Node는 서버가 아니다.
    Javascript 엔진으로 빌드된 Javascript runtime 이다.
    Javascript 로 만든 프로그램들을 실행할 수 있게 해준다.

이벤트 기반으로 작동한다.
    ex) 클릭, 네트워크 요청, 타이머
콜백함수를 사용함.

runtime
    실행환경 이라고 보면 된다. (== 가상머신, 실행기)
    ex) Chrome, Edge, Safari, Fire Fox 등등

------------------------------------------------------------------------------------
호출스택
    Last In, First Out 으로 실행됨
    실행되면 가장 먼저 anonymous 라는 가상의 전역 컨텍스트가 호출 스택에 쌓인다.
    그 이후에 호출되는 함수들이 쌓여서 가장 나중에 쌓인 함수부터 역순으로 실행된다.

------------------------------------------------------------------------------------
변수선언 키워드
가장 큰 차이점은 스코프(적용되는 범위)이다.

1. var
    함수 스코프
    웬만하면 쓰지말자.(ES6 는 var키워드 쓰지 않음)
    function a(){
        var y=3;
    }
    console.log(y); // 에러가 난다. var는 함수스코프이기에 변수 y는 함수 a() 밖에서 쓸 수 없음

2. const
    블록 스코프
    if(true){
        const x=3;
    }
    console.log(x); // 에러가 난다. 블록( { } )을 빠져나오지 못하기 때문.

※ const 를 상수로 생각해서 아예 고칠 수 없다고 생각하면 안된다! JSON형식으로 된 것은 고치기 가능
    ex1)
        const a=3;
        a=5;    // 에러
    
    ex2)
        const b = {name : 'mcj'};
        b.name = 'mincj93'; // 정상작동


3. let
    블록스코프이다. 
    일반적인 변수로 쓸 때 사용.
    같은 변수명으로 2개 이상의 변수를 선언할 수 없다. (var 는 중복선언가능.)

    ex1)
        let foo = 123; // 전역 변수

        {
            let foo = 456; // 지역 변수
            let bar = 456; // 지역 변수
        }

        console.log(foo); // 123
        console.log(bar); // ReferenceError: bar is not defined

------------------------------------------------------------------------------------
백틱 (`)
let won = 1000;
let str = `이 과자는 ${won}원 입니다.`;

str 을 출력하면 "이 과자는 1000원 입니다." 로 출력된다.

------------------------------------------------------------------------------------
화살표함수
    function 키워드를 완벽하게 대체하지 않는다. (this 키워드의 스코프 때문임.)
    this 키워드를 사용하는 함수라면 기존 function 키워드를 그대로 사용하여 함수를 쓰고,
    this 키워드를 안 쓰면 화살표함수로 쓰면 된다.

사용방법
    기존 함수
    function add1(x,y){
        return x+y; 
    }

    화살표함수로 변환
    const add1 = (x,y) =>{
        return x+y;
    }


------------------------------------------------------------------------------------
구조분해
    this가 있으면 구조분해 하지 말아라.
＊module 폴더 참고＊

------------------------------------------------------------------------------------
★★★ promise, async/await

promise
    내용은 실행되었지만 결과를 반환하지 않은 객체
    .then 을 붙이면 결과를 반환한다.
    실행이 완료되지 않았으면 완료된 뒤에 then 내부 함수가 실행됨
    Resolve == 성공시 리턴값이 저장되어 then 으로 연결된다.
    Reject == 실패시 리턴값이 저장되어 catch로 연결된다.
    Finally 부분은 무조건 실행된다.

callback 함수와 promise 함수는 대부분 비동기 이다.
비동기식일 때는 에러처리를 중요시 하자.
callback 함수는 (에러,성공시데이터) 형식이 고정으로 쓰인다.

promise는 성공일 때
.then((data) =>{
        console.log(data.toString());
    })

실패일 때 
.catch((err) =>{
        console.log(err);
        throw err;
    });

처리를 해준다.

------------------------------------------------------------------------------------
__filename
    현재 파일의 경로 + 파일명 값을 준다

__dirname
    현재 폴더의 경로 값을 준다

path
    Window 와 Mac 의 주소처리 하는 슬래쉬가 다른데, 그 주소처리를 일정하게 해준다. 
    
    path.join(__dirname, 'var.js');
    이렇게 쓰면 "현재폴더의 경로/var.js" 를 주소값으로 준다.
    ex) /nodejs-book/lecture/var.js

    path.join(__dirname, '..' ,'var.js');
    중간에 .. 은 상위폴더를 의미하므로
    "현재폴더의 경로의 상위폴더/var.js" 를 주소값으로 준다.
    ex) /nodejs-book/var.js

------------------------------------------------------------------------------------
콜백 형식
Node 에서 콜백은 항상
(에러,데이터) 형식으로 있다.
ex) 

fs.readFile('./readme.txt', (err,data) =>{

});

(err,data) 부분이 콜백이다.
err 은 에러가 났을 때 내역을 가지고 있는 객체이고
data 는 성공시 데이터를 가지고 있을 객체임

------------------------------------------------------------------------------------
버퍼
    일정한 크기까지 데이터를 모았다가 한 번에 처리하는 것
    ※ 버퍼링 == 정해둔 일정한 크기까지 데이터를 모으는 작업
    모은다 > 처리 > 모은다 > 처리  과정 반복
    
스트림
    일청한 크기로 나누어서 여러번 걸쳐 처리하는 것
    버퍼(청크)의 크기를 작게 만들어서 주기적으로 데이터 전달
    ※ 스트리밍 : 일정한 크기의 데이터를 지속적으로 전달하는 작업
    ※ 대부분의 방식이 스트리밍을 씀. 서버 메모리 적게 쓰고 효율적 전송 가능.
    
------------------------------------------------------------------------------------
파일 및 폴더 생성하기
    인프런 "pipe와 스트림 메모리 효율 확인" 강의에 있음.
    fs.access(경로, 옵션, 콜백): 폴더나 파일에 접근할 수 있는지를 체크
    // 두 번째 인자 == F_OK는 파일 존재 여부, R_OK는 읽기 권한 여부, W_OK는 쓰기 권한 여부를 체크
    fs.mkdir('경로/폴더명' , 콜백) - 폴더를 만드는 메서드

------------------------------------------------------------------------------------
에러처리 (예외처리와 같은 말.)
    promise 항상 catch 붙여주기
    async await 항상 try catch 문 써주기
    에러처리 하면 프로세스가 멈추지 않고 계속 진행됨

------------------------------------------------------------------------------------
http 요청 메소드
    put         일부의 수정
    patch       일부의 수정
    ※ put patch 의 차이점
        기존의 속성에 값들이 모두 있다고 가정했을 때
        put 은 모든 속성의 값을 지정해 보내줘야한다. 지정하지 않으면 값이 null 로 들어간다.
        patch 는 수정할 일부분만 지정해서 보내주면 나머지 속성은 그대로 적용이된다.
    post        서버 자원 새로 등록
    delete      서버 자원 삭제
    get         서버 자원 읽기

------------------------------------------------------------------------------------
쿠키
    Expires - 만료기간을 의미함. 지정해주지 않으면 "세션쿠키" 로 변환된다.
    세션쿠키는 브라우저 끄는 순간 사라지는 쿠키임.

    HttpOnly - 자바스크립트로 쿠키 접근 제한. 필수다.

    path - 쿠키 유효 범위. 경로를 써준다. 슬래쉬만(/) 써주면 /로 시작하는 모든 곳에서 쿠키 유효함

------------------------------------------------------------------------------------
세션
    쿠키엔 중요정보도 보일 수 있다. 그걸 보완해서 클라이언트에 세션 키만 제공하는 방법.

------------------------------------------------------------------------------------
npm
    node package manager
    웬만한 코드들, 모듈들 올라가있는 저장소.

package.json
    현재 프로젝트에 대한 정보, 사용중인 패키지 정보를 담은 파일.
    만드는 방법 = 터미널에 npm init 입력
        npm init 한 후 옵션
            main = 첫 진입 파일 지정.
            license = ISC, MIT 상관없음
            git repository = 깃 저장소 주소
    
    "scripts" :{
        "test" : "echo \"Error" ~!~!@$#@$%#",
        "start" : "node index",
    }
    
    "scripts" = 터미널에 치는 명령어에 별명을 붙여주는 것.
    기본적으로 package.json 이 있는 위치에 이동한 후 콘솔에서 "npm run 별명" 을 치면 된다.
    npm run start 를 하면 "node index" 라는 명령어를 실행하게 된다.
    만약 nodemon 이 설치되어있고, "start" : "nodemon app" 이라고 되어있으면
    nodemon app.js 가 실행된다.

npm i 모듈명
    모듈명에 해당하는 npm을 다운로드 한다.

nodemon
    소스를 수정하고 저장했을 때 자동으로 서버를 재시작해준다.
    실시간 파일 감시 모듈이라고 보면 된다.
------------------------------------------------------------------------------------
Express
    주소 요청시 기본적으로 REST 방식 요청을 지정함.
    ex) 
    app.get('url', (callback 함수) =>{
        작업
    });

    app.post('url', (callback 함수) =>{
        작업
    });

    app.patch('url', (callback 함수) =>{
        작업
    });

------------------------------------------------------------------------------------
------------------------------------------------------------------------------------
------------------------------------------------------------------------------------
